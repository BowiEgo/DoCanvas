{"version":3,"file":"x-canvas.js","sources":["../../node_modules/tslib/tslib.es6.js","../../src/utils/general.ts","../../src/utils/normalizeProp.ts","../../src/utils/device.ts","../../src/utils/patchFlags.ts","../../src/core/vnode.ts","../../src/core/createApp.ts","../../src/core/scheduler.ts","../../src/canvas/render/index.ts","../../src/canvas/tree-node/index.ts","../../src/canvas/element/view.ts","../../src/canvas/element/text.ts","../../src/utils/fp.ts","../../src/canvas/element/index.ts","../../src/index.ts","../../src/core/nodeOps.ts","../../src/core/renderer.ts","../../src/core/h.ts","../../src/canvas/index.ts","../../src/canvas/context.ts"],"sourcesContent":["/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\r\n    function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\r\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\r\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\r\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\r\n    var _, done = false;\r\n    for (var i = decorators.length - 1; i >= 0; i--) {\r\n        var context = {};\r\n        for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\r\n        for (var p in contextIn.access) context.access[p] = contextIn.access[p];\r\n        context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\r\n        var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\r\n        if (kind === \"accessor\") {\r\n            if (result === void 0) continue;\r\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\r\n            if (_ = accept(result.get)) descriptor.get = _;\r\n            if (_ = accept(result.set)) descriptor.set = _;\r\n            if (_ = accept(result.init)) initializers.push(_);\r\n        }\r\n        else if (_ = accept(result)) {\r\n            if (kind === \"field\") initializers.push(_);\r\n            else descriptor[key] = _;\r\n        }\r\n    }\r\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\r\n    done = true;\r\n};\r\n\r\nexport function __runInitializers(thisArg, initializers, value) {\r\n    var useValue = arguments.length > 2;\r\n    for (var i = 0; i < initializers.length; i++) {\r\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\r\n    }\r\n    return useValue ? value : void 0;\r\n};\r\n\r\nexport function __propKey(x) {\r\n    return typeof x === \"symbol\" ? x : \"\".concat(x);\r\n};\r\n\r\nexport function __setFunctionName(f, name, prefix) {\r\n    if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\r\n    return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\r\n};\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nexport function __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n","export const EMPTY_OBJ = Object.freeze({})\nexport const EMPTY_ARR = Object.freeze([])\n\nexport const NOOP = () => {}\n\n/**\n * Always return false.\n */\nexport const NO = () => false\n\nconst onRE = /^on[^a-z]/\nexport const isOn = (key: string) => onRE.test(key)\n\nexport const isModelListener = (key: string) => key.startsWith('onUpdate:')\n\nexport const extend = Object.assign\n\nexport const remove = <T>(arr: T[], el: T) => {\n  const i = arr.indexOf(el)\n  if (i > -1) {\n    arr.splice(i, 1)\n  }\n}\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty\nexport const hasOwn = (\n  val: object,\n  key: string | symbol\n): key is keyof typeof val => hasOwnProperty.call(val, key)\n\nexport const isExact = (num: unknown): num is number => {\n  return isNumber.call(null, num)\n}\n\nexport const isAuto = (num: unknown): num is string => {\n  return num === 'auto'\n}\n\nexport const isOuter = (num: unknown): num is string => {\n  if (!isString(num)) return\n  return isArray(num.match('%'))\n}\n\nexport const parseOuter = (num: string): number => {\n  let _n = parseInt(num.replace('%', ''))\n  return isNaN(_n) || _n < 0 ? 0 : _n / 100\n}\n\nexport const isArray = Array.isArray\nexport const isMap = (val: unknown): val is Map<any, any> =>\n  toTypeString(val) === '[object Map]'\nexport const isSet = (val: unknown): val is Set<any> =>\n  toTypeString(val) === '[object Set]'\n\nexport const isDate = (val: unknown): val is Date =>\n  toTypeString(val) === '[object Date]'\nexport const isRegExp = (val: unknown): val is RegExp =>\n  toTypeString(val) === '[object RegExp]'\nexport const isFunction = (val: unknown): val is Function =>\n  typeof val === 'function'\nexport const isString = (val: unknown): val is string => typeof val === 'string'\nexport const isNumber = (val: unknown): val is number => typeof val === 'number'\nexport const isSymbol = (val: unknown): val is symbol => typeof val === 'symbol'\nexport const isObject = (val: unknown): val is Record<any, any> =>\n  val !== null && typeof val === 'object'\n\nexport const isPromise = <T = any>(val: unknown): val is Promise<T> => {\n  return isObject(val) && isFunction(val.then) && isFunction(val.catch)\n}\n\nexport const objectToString = Object.prototype.toString\nexport const toTypeString = (value: unknown): string =>\n  objectToString.call(value)\n\nexport const toRawType = (value: unknown): string => {\n  // extract \"RawType\" from strings like \"[object RawType]\"\n  return toTypeString(value).slice(8, -1)\n}\n\nexport const isPlainObject = (val: unknown): val is object =>\n  toTypeString(val) === '[object Object]'\n\nexport const isIntegerKey = (key: unknown) =>\n  isString(key) &&\n  key !== 'NaN' &&\n  key[0] !== '-' &&\n  '' + parseInt(key, 10) === key\n\nexport const mergeDeep = (target: unknown, ...sources) => {\n  if (!sources.length) return target\n  const source = sources.shift()\n\n  if (isObject(target) && isObject(source)) {\n    for (const key in source) {\n      if (isObject(source[key])) {\n        if (!target[key]) Object.assign(target, { [key]: {} })\n        mergeDeep(target[key], source[key])\n      } else {\n        Object.assign(target, { [key]: source[key] })\n      }\n    }\n  }\n\n  return mergeDeep(target, ...sources)\n}\n","import { isString, isArray, isObject } from './general'\n\nexport type NormalizedStyle = Record<string, string | number>\n\nexport function normalizeStyle(\n  value: unknown\n): NormalizedStyle | string | undefined {\n  if (isArray(value)) {\n    const res: NormalizedStyle = {}\n    for (let i = 0; i < value.length; i++) {\n      const item = value[i]\n      const normalized = isString(item)\n        ? parseStringStyle(item)\n        : (normalizeStyle(item) as NormalizedStyle)\n      if (normalized) {\n        for (const key in normalized) {\n          res[key] = normalized[key]\n        }\n      }\n    }\n    return res\n  } else if (isString(value)) {\n    return value\n  } else if (isObject(value)) {\n    return value\n  }\n}\n\nconst listDelimiterRE = /;(?![^(]*\\))/g\nconst propertyDelimiterRE = /:([^]+)/\nconst styleCommentRE = /\\/\\*.*?\\*\\//gs\n\nexport function parseStringStyle(cssText: string): NormalizedStyle {\n  const ret: NormalizedStyle = {}\n  cssText\n    .replace(styleCommentRE, '')\n    .split(listDelimiterRE)\n    .forEach((item) => {\n      if (item) {\n        const tmp = item.split(propertyDelimiterRE)\n        tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim())\n      }\n    })\n  return ret\n}\n\nexport function normalizeClass(value: unknown): string {\n  let res = ''\n  if (isString(value)) {\n    res = value\n  } else if (isArray(value)) {\n    for (let i = 0; i < value.length; i++) {\n      const normalized = normalizeClass(value[i])\n      if (normalized) {\n        res += normalized + ' '\n      }\n    }\n  } else if (isObject(value)) {\n    for (const name in value) {\n      if (value[name]) {\n        res += name + ' '\n      }\n    }\n  }\n  return res.trim()\n}\n","export const isWX = (function () {\n  try {\n    return Boolean(wx.getSystemInfoSync)\n  } catch (err) {\n    return false\n  }\n})()\n","/**\n * Patch flags are optimization hints generated by the compiler.\n * when a block with dynamicChildren is encountered during diff, the algorithm\n * enters \"optimized mode\". In this mode, we know that the vdom is produced by\n * a render function generated by the compiler, so the algorithm only needs to\n * handle updates explicitly marked by these patch flags.\n *\n * Patch flags can be combined using the | bitwise operator and can be checked\n * using the & operator, e.g.\n *\n * ```js\n * const flag = TEXT | CLASS\n * if (flag & TEXT) { ... }\n * ```\n *\n * Check the `patchElement` function in '../../runtime-core/src/renderer.ts' to see how the\n * flags are handled during diff.\n */\nexport const enum PatchFlags {\n  /**\n   * Indicates an element with dynamic textContent (children fast path)\n   */\n  TEXT = 1,\n\n  /**\n   * Indicates an element with dynamic class binding.\n   */\n  CLASS = 1 << 1,\n\n  /**\n   * Indicates an element with dynamic style\n   * The compiler pre-compiles static string styles into static objects\n   * + detects and hoists inline static objects\n   * e.g. `style=\"color: red\"` and `:style=\"{ color: 'red' }\"` both get hoisted\n   * as:\n   * ```js\n   * const style = { color: 'red' }\n   * render() { return e('div', { style }) }\n   * ```\n   */\n  STYLE = 1 << 2,\n\n  /**\n   * Indicates an element that has non-class/style dynamic props.\n   * Can also be on a component that has any dynamic props (includes\n   * class/style). when this flag is present, the vnode also has a dynamicProps\n   * array that contains the keys of the props that may change so the runtime\n   * can diff them faster (without having to worry about removed props)\n   */\n  PROPS = 1 << 3,\n\n  /**\n   * Indicates an element with props with dynamic keys. When keys change, a full\n   * diff is always needed to remove the old key. This flag is mutually\n   * exclusive with CLASS, STYLE and PROPS.\n   */\n  FULL_PROPS = 1 << 4,\n\n  /**\n   * Indicates an element with event listeners (which need to be attached\n   * during hydration)\n   */\n  HYDRATE_EVENTS = 1 << 5,\n\n  /**\n   * Indicates a fragment whose children order doesn't change.\n   */\n  STABLE_FRAGMENT = 1 << 6,\n\n  /**\n   * Indicates a fragment with keyed or partially keyed children\n   */\n  KEYED_FRAGMENT = 1 << 7,\n\n  /**\n   * Indicates a fragment with unkeyed children.\n   */\n  UNKEYED_FRAGMENT = 1 << 8,\n\n  /**\n   * Indicates an element that only needs non-props patching, e.g. ref or\n   * directives (onVnodeXXX hooks). since every patched vnode checks for refs\n   * and onVnodeXXX hooks, it simply marks the vnode so that a parent block\n   * will track it.\n   */\n  NEED_PATCH = 1 << 9,\n\n  /**\n   * Indicates a component with dynamic slots (e.g. slot that references a v-for\n   * iterated value, or dynamic slot names).\n   * Components with this flag are always force updated.\n   */\n  DYNAMIC_SLOTS = 1 << 10,\n\n  /**\n   * Indicates a fragment that was created only because the user has placed\n   * comments at the root level of a template. This is a dev-only flag since\n   * comments are stripped in production.\n   */\n  DEV_ROOT_FRAGMENT = 1 << 11,\n\n  /**\n   * SPECIAL FLAGS -------------------------------------------------------------\n   * Special flags are negative integers. They are never matched against using\n   * bitwise operators (bitwise matching should only happen in branches where\n   * patchFlag > 0), and are mutually exclusive. When checking for a special\n   * flag, simply check patchFlag === FLAG.\n   */\n\n  /**\n   * Indicates a hoisted static vnode. This is a hint for hydration to skip\n   * the entire sub tree since static content never needs to be updated.\n   */\n  HOISTED = -1,\n  /**\n   * A special flag that indicates that the diffing algorithm should bail out\n   * of optimized mode. For example, on block fragments created by renderSlot()\n   * when encountering non-compiler generated slots (i.e. manually written\n   * render functions, which should always be fully diffed)\n   * OR manually cloneVNodes\n   */\n  BAIL = -2\n}\n\n/**\n * dev only flag -> name mapping\n */\nexport const PatchFlagNames: Record<PatchFlags, string> = {\n  [PatchFlags.TEXT]: `TEXT`,\n  [PatchFlags.CLASS]: `CLASS`,\n  [PatchFlags.STYLE]: `STYLE`,\n  [PatchFlags.PROPS]: `PROPS`,\n  [PatchFlags.FULL_PROPS]: `FULL_PROPS`,\n  [PatchFlags.HYDRATE_EVENTS]: `HYDRATE_EVENTS`,\n  [PatchFlags.STABLE_FRAGMENT]: `STABLE_FRAGMENT`,\n  [PatchFlags.KEYED_FRAGMENT]: `KEYED_FRAGMENT`,\n  [PatchFlags.UNKEYED_FRAGMENT]: `UNKEYED_FRAGMENT`,\n  [PatchFlags.NEED_PATCH]: `NEED_PATCH`,\n  [PatchFlags.DYNAMIC_SLOTS]: `DYNAMIC_SLOTS`,\n  [PatchFlags.DEV_ROOT_FRAGMENT]: `DEV_ROOT_FRAGMENT`,\n  [PatchFlags.HOISTED]: `HOISTED`,\n  [PatchFlags.BAIL]: `BAIL`\n}\n","import {\n  isOn,\n  isString,\n  isObject,\n  isArray,\n  isFunction,\n  normalizeClass,\n  normalizeStyle\n} from '../utils'\nimport { RendererNode } from './renderer'\nimport { ComponentInternalInstance, Data } from './components'\nimport { AppContext } from './createApp'\n\nexport const Fragment = Symbol.for('v-fgt') as any as {\n  __isFragment: true\n  new (): {\n    $props: VNodeProps\n  }\n}\nexport const Text = Symbol.for('v-txt')\nexport const Comment = Symbol.for('v-cmt')\n\nexport type VNodeTypes =\n  | string\n  | VNode\n  | typeof Text\n  | typeof Comment\n  | typeof Fragment\n\nexport type VNodeProps = {\n  key?: string | number | symbol\n  ref_for?: boolean\n  ref_key?: string\n}\n\ntype VNodeChildAtom =\n  | VNode\n  | string\n  | number\n  | boolean\n  | null\n  | undefined\n  | void\n\nexport type VNodeArrayChildren = Array<VNodeArrayChildren | VNodeChildAtom>\n\nexport type VNodeChild = VNodeChildAtom | VNodeArrayChildren\n\nexport type VNodeNormalizedChildren = string | VNodeArrayChildren | null\n\nexport interface VNode<\n  HostNode = RendererNode,\n  ExtraProps = { [key: string]: any }\n> {\n  /**\n   * @internal\n   */\n  __v_isVNode: true\n\n  type: VNodeTypes\n  props: (VNodeProps & ExtraProps) | null\n  children: VNodeNormalizedChildren\n  component: ComponentInternalInstance | null\n\n  el: HostNode | null\n  /**\n   * number of elements contained in a static vnode\n   * @internal\n   */\n  staticCount: number\n\n  // application root node only\n  appContext: AppContext | null\n\n  /**\n   * @internal lexical scope owner instance\n   */\n  ctx: ComponentInternalInstance | null\n}\n\nexport function isVNode(value: any): value is VNode {\n  return value ? value.__v_isVNode === true : false\n}\n\nexport function isSameVNodeType(n1: VNode, n2: VNode): boolean {\n  return n1.type === n2.type\n}\n\nfunction createBaseVNode(\n  type: VNodeTypes,\n  props: (Data & VNodeProps) | null = null,\n  children: unknown = null,\n  patchFlag = 0\n) {\n  const vnode = {\n    __v_isVNode: true,\n    __v_skip: true,\n    type,\n    props,\n    children,\n    component: null,\n    el: null,\n    staticCount: 0,\n    appContext: null,\n    ctx: null\n  } as VNode\n\n  // if (type !== 'Text') {\n  //   normalizeChildren(vnode, children)\n  // }\n  return vnode\n}\n\nexport function createVNode(\n  type: VNodeTypes,\n  props: (Data & VNodeProps) | null = null,\n  children: unknown = null,\n  patchFlag: number = 0\n) {\n  if (isVNode(type)) {\n    const cloned = cloneVNode(type, props, true /* mergeRef: true */)\n    if (children) {\n      normalizeChildren(cloned, children)\n    }\n\n    return cloned\n  }\n\n  // class & style normalization.\n  if (props) {\n    // for reactive or proxy objects, we need to clone it to enable mutation.\n    // props = guardReactiveProps(props)!\n    let { class: klass, style } = props\n    if (klass && !isString(klass)) {\n      props.class = normalizeClass(klass)\n    }\n    if (isObject(style)) {\n      props.style = normalizeStyle(style)\n    }\n  }\n\n  return createBaseVNode(type, props, children, patchFlag)\n}\n\nexport function cloneVNode(\n  vnode: VNode,\n  extraProps?: (Data & VNodeProps) | null,\n  mergeRef = false\n): VNode {\n  if (vnode && typeof vnode !== 'object') {\n    return vnode\n  }\n  // This is intentionally NOT using spread or extend to avoid the runtime\n  // key enumeration cost.\n  const { props, children } = vnode\n  const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props\n  const cloned: VNode = {\n    __v_isVNode: true,\n    type: vnode.type,\n    props: mergedProps,\n    children: isArray(children)\n      ? (children as VNode[]).map(deepCloneVNode)\n      : children,\n    staticCount: vnode.staticCount,\n    appContext: vnode.appContext,\n    component: vnode.component,\n    el: vnode.el,\n    ctx: vnode.ctx\n  }\n  return cloned as any\n}\n\n/**\n * Dev only, for HMR of hoisted vnodes reused in v-for\n * https://github.com/vitejs/vite/issues/2022\n */\nfunction deepCloneVNode(vnode: VNode): VNode {\n  const cloned = cloneVNode(vnode)\n  if (isArray(vnode.children)) {\n    cloned.children = (vnode.children as VNode[]).map(deepCloneVNode)\n  }\n  return cloned\n}\n\n/**\n * @private\n */\nexport function createTextVNode(text: string = ' ', flag: number = 0): VNode {\n  return createVNode('Text', null, text)\n}\n\nexport function normalizeVNode(child: VNodeChild): VNode {\n  if (child == null || typeof child === 'boolean') {\n    // empty placeholder\n    return createVNode(Comment)\n  } else if (isArray(child)) {\n    // fragment\n    return createVNode(\n      Fragment,\n      null,\n      // #3666, avoid reference pollution when reusing vnode\n      child.slice()\n    )\n  } else if (typeof child === 'object') {\n    // already vnode, this should be the most common since compiled templates\n    // always produce all-vnode children arrays\n    return cloneIfMounted(child)\n  } else {\n    // strings and numbers\n    return createTextVNode(String(child))\n  }\n}\n\nexport function cloneIfMounted(child: VNode): VNode {\n  return cloneVNode(child)\n}\n\nexport function normalizeChildren(vnode: VNode, children: unknown) {\n  if (children == null) {\n    children = null\n  } else if (isArray(children)) {\n  } else if (typeof children === 'object') {\n  } else if (isFunction(children)) {\n  } else {\n    children = [createTextVNode(children as string)]\n  }\n  vnode.children = children as VNodeNormalizedChildren\n}\n\nexport function mergeProps(...args: (Data & VNodeProps)[]) {\n  const ret: Data = {}\n  for (let i = 0; i < args.length; i++) {\n    const toMerge = args[i]\n    for (const key in toMerge) {\n      if (key === 'class') {\n        if (ret.class !== toMerge.class) {\n          ret.class = normalizeClass([ret.class, toMerge.class])\n        }\n      } else if (key === 'style') {\n        ret.style = normalizeStyle([ret.style, toMerge.style])\n      } else if (isOn(key)) {\n        const existing = ret[key]\n        const incoming = toMerge[key]\n        if (\n          incoming &&\n          existing !== incoming &&\n          !(isArray(existing) && existing.includes(incoming))\n        ) {\n          ret[key] = existing\n            ? [].concat(existing as any, incoming as any)\n            : incoming\n        }\n      } else if (key !== '') {\n        ret[key] = toMerge[key]\n      }\n    }\n  }\n  return ret\n}\n","import { Component, ComponentInternalInstance, Data } from './components'\nimport { createVNode } from './vnode'\n\nexport interface App<HostElement = any> {\n  _uid: number\n  _component: Component\n  _props: Data | null\n  _container: HostElement | null\n  _instance: ComponentInternalInstance | null\n\n  mount(rootContainer: HostElement | string): any\n}\n\nexport interface AppContext {\n  app: App // for devtools\n}\n\nexport type createApp<HostElement> = (\n  rootComponent: Component,\n  rootProps?: Data | null\n) => App<HostElement>\n\nlet uid = 0\n\nexport function createAppAPI(render) {\n  return function createApp(rootComponent, rootProps = null) {\n    const app: App = {\n      _uid: uid++,\n      _component: rootComponent as Component,\n      _props: rootProps,\n      _container: null,\n      _instance: null,\n\n      mount(rootContainer): any {\n        const vnode = createVNode(rootComponent, rootProps)\n\n        app._container = rootContainer\n\n        render(vnode, rootContainer)\n      }\n    }\n\n    return app\n  }\n}\n","import { ComponentInternalInstance } from './components'\n\nexport interface SchedulerJob extends Function {\n  id?: number\n  pre?: boolean\n  active?: boolean\n  computed?: boolean\n  /**\n   * Indicates whether the effect is allowed to recursively trigger itself\n   * when managed by the scheduler.\n   *\n   * By default, a job cannot trigger itself because some built-in method calls,\n   * e.g. Array.prototype.push actually performs reads as well (#1740) which\n   * can lead to confusing infinite loops.\n   * The allowed cases are component update functions and watch callbacks.\n   * Component update functions may update child component props, which in turn\n   * trigger flush: \"pre\" watch callbacks that mutates state that the parent\n   * relies on (#1801). Watch callbacks doesn't track its dependencies so if it\n   * triggers itself again, it's likely intentional and it is the user's\n   * responsibility to perform recursive state mutation that eventually\n   * stabilizes (#1727).\n   */\n  allowRecurse?: boolean\n  /**\n   * Attached by renderer.ts when setting up a component's render effect\n   * Used to obtain component information when reporting max recursive updates.\n   * dev only.\n   */\n  ownerInstance?: ComponentInternalInstance\n}\n\nexport type SchedulerJobs = SchedulerJob | SchedulerJob[]\n\nlet isFlushing = false\nlet isFlushPending = false\n\nconst queue: SchedulerJob[] = []\nlet flushIndex = 0\n\nconst pendingPostFlushCbs: SchedulerJob[] = []\nlet activePostFlushCbs: SchedulerJob[] | null = null\nlet postFlushIndex = 0\n\nconst resolvedPromise = /*#__PURE__*/ Promise.resolve() as Promise<any>\nlet currentFlushPromise: Promise<void> | null = null\n\nconst RECURSION_LIMIT = 100\ntype CountMap = Map<SchedulerJob, number>\n\nexport function flushPreFlushCbs(\n  seen?: CountMap,\n  // if currently flushing, skip the current job itself\n  i = isFlushing ? flushIndex + 1 : 0\n) {\n  seen = seen || new Map()\n  for (; i < queue.length; i++) {\n    const cb = queue[i]\n    if (cb && cb.pre) {\n      if (checkRecursiveUpdates(seen!, cb)) {\n        continue\n      }\n      queue.splice(i, 1)\n      i--\n      cb()\n    }\n  }\n}\n\nexport function flushPostFlushCbs(seen?: CountMap) {\n  if (pendingPostFlushCbs.length) {\n    const deduped = [...new Set(pendingPostFlushCbs)]\n    pendingPostFlushCbs.length = 0\n\n    // #1947 already has active queue, nested flushPostFlushCbs call\n    if (activePostFlushCbs) {\n      activePostFlushCbs.push(...deduped)\n      return\n    }\n\n    activePostFlushCbs = deduped\n\n    seen = seen || new Map()\n\n    activePostFlushCbs.sort((a, b) => getId(a) - getId(b))\n\n    for (\n      postFlushIndex = 0;\n      postFlushIndex < activePostFlushCbs.length;\n      postFlushIndex++\n    ) {\n      if (checkRecursiveUpdates(seen!, activePostFlushCbs[postFlushIndex])) {\n        continue\n      }\n      activePostFlushCbs[postFlushIndex]()\n    }\n    activePostFlushCbs = null\n    postFlushIndex = 0\n  }\n}\n\nconst getId = (job: SchedulerJob): number =>\n  job.id == null ? Infinity : job.id\n\nfunction checkRecursiveUpdates(seen: CountMap, fn: SchedulerJob) {\n  if (!seen.has(fn)) {\n    seen.set(fn, 1)\n  } else {\n    const count = seen.get(fn)!\n    if (count > RECURSION_LIMIT) {\n      return true\n    } else {\n      seen.set(fn, count + 1)\n    }\n  }\n}\n","import { Color } from '../css/types/color'\nimport { CanvasElement } from '../element'\n\nexport type RenderConfigurations = RenderOptions & {\n  backgroundColor: Color | null\n}\n\nexport interface RenderOptions {\n  canvas?: HTMLCanvasElement\n  ctx: CanvasRenderingContext2D\n  dpr?: number\n  width: number\n  height: number\n}\n\nexport interface CanvasRenderer {\n  canvas: HTMLCanvasElement\n  ctx: CanvasRenderingContext2D\n  dpr?: number\n  render(): void\n}\n\nexport function createRenderer(options: RenderConfigurations): CanvasRenderer {\n  let renderer: CanvasRenderer = {\n    canvas: options.canvas,\n    ctx: options.ctx,\n    dpr: options.dpr || 1,\n    render() {}\n  }\n\n  return renderer\n}\n","export type TreeNodeChildren = Array<any> | string\n\nexport interface TreeNode {\n  __v_isTreeNode: boolean\n  _children: TreeNodeChildren\n  children: TreeNodeChildren\n  parent: TreeNode | null\n  root: TreeNode | null\n  prev: TreeNode | string | null\n  next: TreeNode | string | null\n  context: any\n  hasChildren(): boolean\n  appendChild(child: TreeNode): void\n  prependChild(child: TreeNode): void\n  removeChild(child: TreeNode): void\n  append(): void\n  prepend(): void\n  remove(): void\n}\n\nexport function isTreeNode(value: any): value is TreeNode {\n  return value ? value.__v_isTreeNode === true : false\n}\n\nexport function isEndNode(node) {\n  return node.parent && !node.next && !node.hasChildren()\n}\n\nexport function createTreeNode(options) {\n  const treeNode: TreeNode = {\n    __v_isTreeNode: true,\n    _children: [],\n    parent: null,\n    root: null,\n    prev: null,\n    next: null,\n    context: options.context,\n    get children() {\n      return treeNode._children\n    },\n    hasChildren,\n    appendChild,\n    prependChild,\n    removeChild,\n    append,\n    prepend,\n    remove\n  }\n\n  function _setParent(child: TreeNode, parent): void {\n    child.parent = parent\n  }\n\n  function _setSibling(\n    node: TreeNode,\n    prev: TreeNode | string | null,\n    next: TreeNode | null\n  ): void {\n    node.prev = prev\n    node.next = next\n  }\n\n  function hasChildren() {\n    return Array.isArray(treeNode._children) && treeNode._children.length\n      ? true\n      : false\n  }\n\n  function appendChild(child) {\n    if (!isTreeNode(child)) throw Error('Unknown treeNode type')\n\n    const prev = treeNode._children[treeNode._children.length - 1] || null\n    if (prev && isTreeNode(prev)) {\n      _setSibling(prev, prev.prev, child)\n    }\n\n    Array.isArray(treeNode._children) && treeNode._children.push(child)\n\n    _setParent(child, treeNode)\n    _setSibling(child, prev, null)\n  }\n\n  function prependChild(child) {\n    if (!isTreeNode(child)) throw Error('Unknown treeNode type')\n  }\n\n  function removeChild(child) {\n    if (!isTreeNode(child)) throw Error('Unknown treeNode type')\n  }\n\n  function append() {}\n\n  function prepend() {}\n\n  function remove() {}\n\n  return treeNode\n}\n\nexport function connectChildren(el) {\n  if (el.hasChildren()) {\n    el.children = el.children.filter((item) => {\n      isTreeNode(item)\n    })\n    el._getChildren().map((child, index) => {\n      child._setParent(el)\n      child._setSibling(\n        el._getChildren()[index - 1],\n        el._getChildren()[index + 1]\n      )\n      connectChildren(child)\n    })\n  }\n}\n","import { CanvasElement } from '.'\n\ninterface ViewElement extends CanvasElement {\n  paint(): void\n}\n\nexport function toViewElement(element: CanvasElement): ViewElement {\n  function paint() {\n    const renderer = this.getRenderer()\n\n    if (this.options.render) {\n      this.options.render(renderer.getCtx(), renderer.getCanvas(), this)\n    } else {\n      renderer._drawBackground(this)\n      renderer._drawBox(this)\n    }\n  }\n\n  element.paint = paint\n\n  return element\n}\n","import { isAuto, isExact } from '../../utils'\nimport { CanvasElement } from '.'\nimport { CanvasRenderer } from '../render'\nimport STYLE_CONSTANT, { ElementStyleType } from '../styleConstant'\n\ntype TextOptions = {}\n\ntype Layout = {}\n\ntype TextLine = {\n  text: string\n  layout: Layout\n}\n\nexport interface TextElement extends CanvasElement {\n  // layout: any\n  // lines: TextLine[]\n  // debugColor: string\n  paint(): void\n}\n\nexport function toTextElement(element: CanvasElement): TextElement {\n  function paint() {\n    // const renderer = this.getRenderer()\n    // renderer._drawBackground(this)\n    // renderer._drawText(tetxt)\n    // renderer._drawBox(text)\n  }\n\n  element.debugColor = 'blue'\n  element.paint = paint\n\n  return element\n}\n","export const curry = (fn) => {\n  return function curried(...args) {\n    if (args.length >= fn.length) {\n      return fn.apply(this, args)\n    } else {\n      return function (...args2) {\n        return curried.apply(this, args.concat(args2))\n      }\n    }\n  }\n}\n\nexport const pipe = function (funcs) {\n  let len = funcs.length\n  let index = 0\n  let result\n  return function f1(...args) {\n    // 第一次args是传进来的参数，之后args==result\n    result = funcs[index].apply(this, args)\n    if (index >= len - 1) {\n      // 重置下标为0\n      index = 0\n      return result\n    }\n    index++\n    return f1.call(null, result)\n  }\n}\n// compose的实现\nexport const compose = function (args) {\n  return pipe(args.reverse())\n}\n","import STYLE_CONSTANT, { ElementStyleType } from '../styleConstant'\nimport { TreeNode, createTreeNode } from '../tree-node'\nimport {\n  isAuto,\n  isOuter,\n  isExact,\n  parseOuter,\n  findRelativeTo,\n  floor,\n  isArray,\n  mergeDeep,\n  isString,\n  isNumber,\n  extend\n} from '../../utils'\nimport { toViewElement } from './view'\nimport { createTextElement, toTextElement } from './text'\nimport { compose, curry, pipe } from '../../utils/fp'\nimport { VISIBILITY } from '../css/property-descriptors/visibility'\nimport { RenderableElement, createRenderableElement } from './renderableElement'\nimport { CanvasRenderer } from '../render'\n\nexport const DEFAULT_CONTAINER = {\n  styles: {},\n  renderStyles: {\n    width: 0,\n    height: 0,\n    paddingWidth: 0,\n    paddingHeight: 0,\n    paddingTop: 0,\n    paddingBottom: 0,\n    paddingLeft: 0,\n    paddingRight: 0,\n    marginLeft: 0,\n    marginRight: 0,\n    marginTop: 0,\n    marginBottom: 0,\n    borderTopWidth: 0,\n    borderBottomWidth: 0,\n    borderLeftWidth: 0,\n    borderRightWidth: 0,\n    contentWidth: 0,\n    contentHeight: 0,\n    fullBoxWidth: 0,\n    fullBoxHeight: 0,\n    lineCap: 'butt',\n    visible: true\n  },\n  layout: {\n    x: 0,\n    y: 0,\n    contentX: 0,\n    contentY: 0\n  }\n}\n\n// export enum ElementTypes {\n//   root = 'root',\n//   view = 'view',\n//   text = 'text',\n//   img = 'img'\n// }\n\ntype ExtendStyles = {\n  textAlign?: string\n  lineHeight?: number\n  fontSize?: number\n  color?: string\n  fontFamily?: string\n  alignItems?: string\n  alignSelf?: string\n  visible?: boolean\n}\n\nexport type Layout = {\n  x: number\n  y: number\n  contentX?: number\n  contentY?: number\n}\n\nexport type RenderStyle = {\n  width: number\n  height: number\n  paddingWidth: number\n  paddingHeight: number\n  paddingTop: number\n  paddingBottom: number\n  paddingLeft: number\n  paddingRight: number\n  marginLeft: number\n  marginRight: number\n  marginTop: number\n  marginBottom: number\n  contentWidth: number\n  contentHeight: number\n  fullBoxWidth: number\n  fullBoxHeight: number\n  lineCap: string // butt round square\n  visible: boolean\n}\n\ntype DefaultContainer = {\n  styles: ElementStyleType\n  renderStyles: RenderStyle\n  layout: Layout\n}\n\ntype CanvasElementContainer = CanvasElement | DefaultContainer\n\nexport type ElementOptions = {\n  style?: ElementStyleType\n  text?: string\n}\n\nexport function isCanvasElement(value: any): value is CanvasElement {\n  return value ? value.__v_isCanvasElement === true : false\n}\n\nexport interface CanvasElement {\n  __v_isCanvasElement: boolean\n  type: string\n  options: ElementOptions\n  styles: ElementStyleType\n  debugColor: string | null\n  node: TreeNode\n  appendChild(child: CanvasElement): void\n  getContainer(): CanvasElement\n  isVisible(): boolean\n}\n\nexport function createBaseElement(\n  type: string,\n  options: ElementOptions = {},\n  children?: CanvasElement[] | string\n): CanvasElement {\n  let props = {\n    __v_isCanvasElement: true,\n    type,\n    options,\n    styles: {} as ElementStyleType,\n    node: null,\n    debugColor: null\n  }\n\n  let element: CanvasElement = {\n    ...props,\n    appendChild,\n    getContainer,\n    isVisible\n  }\n\n  let treeNode = createTreeNode({ context: element })\n  element.node = treeNode\n\n  function appendChild(child) {\n    treeNode.appendChild(child.node)\n  }\n\n  function getContainer() {\n    return element.node.parent ? element.node.parent.context : null\n  }\n\n  function isVisible(): boolean {\n    return true\n    // return (\n    //   this.styles.display > 0 &&\n    //   this.styles.opacity > 0 &&\n    //   this.style.visibility === VISIBILITY.VISIBLE\n    // )\n  }\n\n  if (element.type === 'body') {\n    element.styles = {\n      width: '100%',\n      height: '100%'\n    } as ElementStyleType\n  }\n\n  return element\n}\n\nexport function createElement(\n  type: string,\n  options: ElementOptions = {},\n  children?: CanvasElement[] | string\n): CanvasElement {\n  switch (type) {\n    case 'text':\n      return compose([toTextElement, createBaseElement])(\n        type,\n        options,\n        children\n      )\n    default:\n      return compose([toViewElement, createBaseElement])(\n        type,\n        options,\n        children\n      )\n  }\n}\n\n// function _initStyles(elm: CanvasElement): ElementStyleType {\n//   let styles = mergeDeep(\n//     {},\n//     _getDefaultStyles(),\n//     _getExtendStyles(elm),\n//     elm.options.style || {}\n//   )\n\n//   if (elm.type === 'root') {\n//     styles.width = '100%'\n//     styles.height = '100%'\n//   }\n\n//   completeStyles(styles, elm.container.styles, true)\n//   return styles\n// }\n\n// function _getDefaultStyles() {\n//   return STYLE_CONSTANT.DEFAULT_STYLES\n// }\n\n// function _getExtendStyles(elm) {\n//   let extendStyles = {} as ExtendStyles\n//   const extendKeys = [\n//     'textAlign',\n//     'fontFamily',\n//     'fontWeight',\n//     'fontSize',\n//     'lineHeight',\n//     'wordSpacing',\n//     'letterSpacing',\n//     'color',\n//     'alignItems',\n//     'visibility'\n//   ]\n\n//   extendKeys.map((key) => {\n//     const value = elm.container.styles[key]\n//     if (value) extendStyles[key] = value\n//   })\n\n//   return extendStyles\n// }\n\n// function parsePaddingBox(rawBoxValue, parentBoxValue, margin): number {\n//   let result = 0\n\n//   if (isAuto(rawBoxValue)) {\n//   } else if (isOuter(rawBoxValue)) {\n//     result = parseOuter(rawBoxValue) * parentBoxValue - margin\n//   } else {\n//     result = rawBoxValue\n//   }\n\n//   return result\n// }\n\n// function _getRenderStyles(elm: CanvasElement): RenderStyle {\n//   let renderStyles = {} as RenderStyle\n//   extend(renderStyles, elm.styles)\n//   const parentWidth = elm.container.renderStyles.contentWidth\n//   const parentHeight = elm.container.renderStyles.contentHeight\n\n//   renderStyles.paddingWidth = parsePaddingBox(\n//     elm.styles.width,\n//     parentWidth,\n//     renderStyles.marginLeft + renderStyles.marginRight\n//   )\n\n//   renderStyles.paddingHeight = parsePaddingBox(\n//     elm.styles.height,\n//     parentHeight,\n//     renderStyles.marginTop + renderStyles.marginBottom\n//   )\n\n//   // 初始化contentWidth\n//   // https://www.w3schools.com/css/css_boxmodel.asp\n\n//   renderStyles.contentWidth = calcContentBox(renderStyles, [\n//     'paddingWidth',\n//     'paddingLeft',\n//     'paddingRight'\n//   ])\n\n//   renderStyles.contentHeight = calcContentBox(renderStyles, [\n//     'paddingHeight',\n//     'paddingTop',\n//     'paddingBottom'\n//   ])\n\n//   renderStyles.fullBoxWidth = calcFullBox(renderStyles, [\n//     'contentWidth',\n//     'paddingLeft',\n//     'paddingRight',\n//     'borderLeftWidth',\n//     'borderRightWidth',\n//     'marginLeft',\n//     'marginRight'\n//   ])\n\n//   renderStyles.fullBoxHeight = calcFullBox(renderStyles, [\n//     'contentHeight',\n//     'paddingTop',\n//     'paddingBottom',\n//     'borderTopWidth',\n//     'borderBottomWidth',\n//     'marginTop',\n//     'marginBottom'\n//   ])\n\n//   renderStyles.width =\n//     renderStyles.paddingWidth +\n//     renderStyles.marginLeft +\n//     renderStyles.marginRight +\n//     getTotalBorderWidth(renderStyles)\n//   renderStyles.height =\n//     renderStyles.paddingHeight +\n//     renderStyles.marginTop +\n//     renderStyles.marginBottom +\n//     getTotalBorderHeight(renderStyles)\n\n//   console.log('renderStyles', renderStyles)\n\n//   return renderStyles\n// }\n\n// function getContainerLayout(elm: CanvasElement): Layout {\n//   const container = elm.container\n\n//   return {\n//     width: container.renderStyles.width,\n//     height: container.renderStyles.height,\n//     paddingTop: container.renderStyles.paddingTop,\n//     paddingBottom: container.renderStyles.paddingBottom,\n//     paddingLeft: container.renderStyles.paddingLeft,\n//     paddingRight: container.renderStyles.paddingRight,\n//     marginLeft: container.renderStyles.marginLeft,\n//     marginRight: container.renderStyles.marginRight,\n//     marginTop: container.renderStyles.marginTop,\n//     marginBottom: container.renderStyles.marginBottom,\n//     x: container.layout.x,\n//     y: container.layout.y,\n//     contentX: container.layout.contentX,\n//     contentY: container.layout.contentY,\n//     contentWidth: container.layout.contentWidth,\n//     contentHeight: container.layout.contentHeight\n//   }\n// }\n\n// function getTotalBorderWidth(renderStyles) {\n//   return renderStyles.borderLeftWidth + renderStyles.borderRightWidth\n// }\n\n// function getTotalBorderHeight(renderStyles) {\n//   return renderStyles.borderTopWidth + renderStyles.borderBottomWidth\n// }\n\n// const mapValues = (target, props) => {\n//   let arr = []\n//   props.map((prop) => arr.push(target[prop]))\n//   return arr\n// }\n\n// const calcContentBox = (\n//   renderStyles: RenderStyle,\n//   props: [string, string, string]\n// ) => curry((a, b, c) => a - b - c)(...mapValues(renderStyles, props))\n\n// const calcFullBox = (\n//   renderStyles: RenderStyle,\n//   props: [string, string, string, string, string, string, string]\n// ) =>\n//   curry((a, b, c, d, e, f, g) => a + b + c + d + e + f + g)(\n//     ...mapValues(renderStyles, props)\n//   )\n","import { createAppAPI } from './core/createApp'\nimport { createRenderer } from './core/renderer'\nimport { createNodeOps } from './core/nodeOps'\nimport { h } from './core/h'\nimport { createDoCanvas } from './canvas'\n\nconst XCanvas = {\n  createAppAPI,\n  createNodeOps,\n  createRenderer,\n  h,\n  createDoCanvas\n}\n\nexport default XCanvas\n","import { RendererOptions } from './renderer'\n\nexport function createNodeOps(createElement): RendererOptions {\n  return {\n    insert: (child, parent, anchor) => {\n      if (!child) {\n        return\n      }\n\n      parent.appendChild(child)\n    },\n\n    remove: (child) => {},\n\n    createElement: (tag, props) => {\n      props = props || {}\n      const { style } = props\n\n      switch (tag) {\n        default:\n          return createElement('view', { style })\n      }\n    },\n\n    createText: (text) => {\n      // console.log('createText', text)\n      return createElement('text', {}, text)\n    },\n\n    createComment: (text) => {},\n\n    setText: (node, text) => {},\n\n    setElementText: (el, text) => {},\n\n    parentNode: (node) => node.parentNode as Element | null,\n\n    nextSibling: (node) => node.nextSibling\n\n    //   querySelector: (selector) => {},\n  }\n}\n","import {\n  VNode,\n  VNodeProps,\n  VNodeArrayChildren,\n  isSameVNodeType,\n  normalizeVNode\n} from './vnode'\nimport { createAppAPI } from './createApp'\nimport { ComponentInternalInstance, Data } from './components'\nimport { flushPreFlushCbs, flushPostFlushCbs } from './scheduler'\nimport { EMPTY_OBJ, EMPTY_ARR, PatchFlags, ShapeFlags } from '../utils'\n\nexport type RootRenderFunction<HostElement = RendererElement> = (\n  vnode: VNode | null,\n  container: HostElement,\n  isSVG?: boolean\n) => void\n\ntype MountChildrenFn = (\n  children: VNodeArrayChildren,\n  container: RendererElement,\n  anchor: RendererNode | null,\n  parentComponent: ComponentInternalInstance | null,\n  start?: number\n) => void\n\ntype NextFn = (vnode: VNode) => RendererNode | null\n\ntype RemoveFn = (vnode: VNode) => void\n\ntype UnmountChildrenFn = (\n  children: VNode[],\n  parentComponent: ComponentInternalInstance | null,\n  // parentSuspense: SuspenseBoundary | null,\n  doRemove?: boolean,\n  optimized?: boolean,\n  start?: number\n) => void\n\ntype ProcessTextOrCommentFn = (\n  n1: VNode | null,\n  n2: VNode,\n  container: RendererElement,\n  anchor: RendererNode | null\n) => void\n\nexport interface RendererOptions<\n  HostNode = RendererNode,\n  HostElement = RendererElement\n> {\n  patchProp(\n    el: HostElement,\n    key: string,\n    prevValue: any,\n    nextValue: any,\n    prevChildren?: VNode<HostNode, HostElement>[],\n    parentComponent?: ComponentInternalInstance | null,\n    unmountChildren?: UnmountChildrenFn\n  ): void\n  insert(el: HostNode, parent: HostElement, anchor?: HostNode | null): void\n  remove(el: HostNode): void\n  createElement(\n    type: string,\n    vnodeProps?: (VNodeProps & { [key: string]: any }) | null\n  ): HostElement\n  createText(text: string): HostNode\n  createComment(text: string): HostNode\n  setText(node: HostNode, text: string): void\n  setElementText(node: HostElement, text: string): void\n  parentNode(node: HostNode): HostElement | null\n  nextSibling(node: HostNode): HostNode | null\n  // querySelector?(selector: string): HostElement | null\n}\n\nexport interface RendererNode {\n  [key: string]: any\n}\n\nexport interface RendererElement extends RendererNode {}\n\ntype PatchFn = (\n  n1: VNode | null, // null means this is a mount\n  n2: VNode,\n  container: RendererElement,\n  anchor?: RendererNode | null,\n  parentComponent?: ComponentInternalInstance | null\n) => void\n\ntype PatchChildrenFn = (\n  n1: VNode | null,\n  n2: VNode,\n  container: RendererElement,\n  anchor: RendererNode | null,\n  parentComponent: ComponentInternalInstance | null\n) => void\n\ntype UnmountFn = (\n  vnode: VNode,\n  parentComponent: ComponentInternalInstance | null,\n  doRemove?: boolean,\n  optimized?: boolean\n) => void\n\nexport function createRenderer(options: RendererOptions): any {\n  const {\n    insert: hostInsert,\n    remove: hostRemove,\n    patchProp: hostPatchProp,\n    createElement: hostCreateElement,\n    createText: hostCreateText,\n    createComment: hostCreateComment,\n    setText: hostSetText,\n    setElementText: hostSetElementText,\n    parentNode: hostParentNode,\n    nextSibling: hostNextSibling\n  } = options\n\n  const patch: PatchFn = (\n    n1,\n    n2,\n    container,\n    anchor = null,\n    parentComponent = null\n  ) => {\n    // console.log('patch', n1, n2, container)\n    if (n1 === n2) {\n      return\n    }\n\n    // patching & not same type, unmount old tree\n    if (n1 && !isSameVNodeType(n1, n2)) {\n      anchor = getNextHostNode(n1)\n      unmount(n1, parentComponent, true)\n      n1 = null\n    }\n\n    const { type } = n2\n    switch (type) {\n      case 'Text':\n        processText(n1, n2, container, anchor)\n        break\n      // case 'Comment':\n      //   processCommentNode(n1, n2, container, anchor)\n      //   break\n      default:\n        processElement(n1, n2, container, anchor, parentComponent)\n    }\n  }\n\n  const processText: ProcessTextOrCommentFn = (n1, n2, container, anchor) => {\n    if (n1 == null) {\n      hostInsert(hostCreateText(n2.children as string), container, anchor)\n    } else {\n      if (n2.children !== n1.children) {\n        hostSetText(n2, n2.children as string)\n      }\n    }\n  }\n\n  const processElement = (\n    n1: VNode | null,\n    n2: VNode,\n    container: RendererElement,\n    anchor: RendererNode | null,\n    parentComponent: ComponentInternalInstance | null\n  ) => {\n    if (n1 == null) {\n      mountElement(n2, container, anchor, parentComponent)\n    } else {\n      patchElement(n1, n2, parentComponent)\n    }\n  }\n\n  const mountElement = (\n    vnode: VNode,\n    container: RendererElement,\n    anchor: RendererNode | null,\n    parentComponent: ComponentInternalInstance | null\n  ) => {\n    let el: RendererElement\n    const { type, props } = vnode\n    // console.log('mountElement', vnode, container, anchor, parentComponent)\n\n    el = vnode.el = hostCreateElement(vnode.type as string, props)\n\n    // mount children first, since some props may rely on child content\n    // being already rendered, e.g. `<select value>`\n\n    mountChildren(\n      vnode.children as VNodeArrayChildren,\n      el,\n      null,\n      parentComponent\n    )\n\n    // props\n    if (props) {\n      // for (const key in props) {\n      //   if (key !== 'value' && !isReservedProp(key)) {\n      //     hostPatchProp(\n      //       el,\n      //       key,\n      //       null,\n      //       props[key],\n      //       isSVG,\n      //       vnode.children as VNode[],\n      //       parentComponent,\n      //       parentSuspense,\n      //       unmountChildren\n      //     )\n      //   }\n      // }\n\n      if ('value' in props) {\n        // hostPatchProp(el, 'value', null, props.value)\n      }\n    }\n\n    hostInsert(el, container, anchor)\n  }\n\n  const mountChildren: MountChildrenFn = (\n    children,\n    container,\n    anchor,\n    parentComponent,\n    start = 0\n  ) => {\n    // console.log('mountChildren', children, container, anchor, parentComponent)\n    if (typeof children === 'string') {\n      patch(null, normalizeVNode(children), container, anchor, parentComponent)\n    } else {\n      for (let i = start; i < children.length; i++) {\n        const child = normalizeVNode(children[i])\n        patch(null, child, container, anchor, parentComponent)\n      }\n    }\n  }\n\n  const patchElement = (\n    n1: VNode,\n    n2: VNode,\n    parentComponent: ComponentInternalInstance | null\n  ) => {\n    const el = (n2.el = n1.el!)\n\n    const oldProps = n1.props || EMPTY_OBJ\n    const newProps = n2.props || EMPTY_OBJ\n\n    patchChildren(n1, n2, el, null, parentComponent)\n\n    // text\n    if (n1.children !== n2.children) {\n      hostSetElementText(el, n2.children as string)\n    }\n\n    patchProps(el, n2, oldProps, newProps, parentComponent)\n  }\n\n  const patchChildren: PatchChildrenFn = (\n    n1,\n    n2,\n    container,\n    anchor,\n    parentComponent\n  ) => {\n    const c1 = n1 && n1.children\n    const c2 = n2.children\n\n    patchUnkeyedChildren(\n      c1 as VNode[],\n      c2 as VNodeArrayChildren,\n      container,\n      anchor,\n      parentComponent\n    )\n  }\n\n  const patchUnkeyedChildren = (\n    c1: VNode[],\n    c2: VNodeArrayChildren,\n    container: RendererElement,\n    anchor: RendererNode | null,\n    parentComponent: ComponentInternalInstance | null\n  ) => {\n    c1 = c1 || EMPTY_ARR\n    c2 = c2 || EMPTY_ARR\n    const oldLength = c1.length\n    const newLength = c2.length\n    const commonLength = Math.min(oldLength, newLength)\n    let i\n    for (i = 0; i < commonLength; i++) {\n      const nextChild = normalizeVNode(c2[i])\n      patch(c1[i], nextChild, container, null, parentComponent)\n    }\n    if (oldLength > newLength) {\n      // remove old\n      unmountChildren(c1, parentComponent, true, false, commonLength)\n    } else {\n      // mount new\n      mountChildren(c2, container, anchor, parentComponent, commonLength)\n    }\n  }\n\n  const patchProps = (\n    el: RendererElement,\n    vnode: VNode,\n    oldProps: Data,\n    newProps: Data,\n    parentComponent: ComponentInternalInstance | null\n  ) => {\n    if (oldProps !== newProps) {\n      if (oldProps !== EMPTY_OBJ) {\n        for (const key in oldProps) {\n          hostPatchProp(\n            el,\n            key,\n            oldProps[key],\n            null,\n            vnode.children as VNode[],\n            parentComponent,\n            unmountChildren\n          )\n        }\n      }\n      for (const key in newProps) {\n        const next = newProps[key]\n        const prev = oldProps[key]\n        // defer patching value\n        if (next !== prev && key !== 'value') {\n          hostPatchProp(\n            el,\n            key,\n            prev,\n            next,\n            vnode.children as VNode[],\n            parentComponent,\n            unmountChildren\n          )\n        }\n      }\n      if ('value' in newProps) {\n        hostPatchProp(el, 'value', oldProps.value, newProps.value)\n      }\n    }\n  }\n\n  const unmount: UnmountFn = (\n    vnode,\n    parentComponent,\n    doRemove = false,\n    optimized = false\n  ) => {\n    const { type, props, children } = vnode\n\n    unmountChildren(children as VNode[], parentComponent)\n\n    if (doRemove) {\n      remove(vnode)\n    }\n  }\n\n  const remove: RemoveFn = (vnode) => {\n    const performRemove = () => {\n      hostRemove(vnode)\n    }\n\n    performRemove()\n  }\n\n  const unmountChildren: UnmountChildrenFn = (\n    children,\n    parentComponent,\n    doRemove = false,\n    optimized = false,\n    start = 0\n  ) => {\n    for (let i = start; i < children.length; i++) {\n      unmount(children[i], parentComponent, doRemove)\n    }\n  }\n\n  const getNextHostNode: NextFn = (vnode) => {\n    return hostNextSibling(vnode!)\n  }\n\n  const render: RootRenderFunction = (vnode, container) => {\n    // console.log('render:', vnode, container, container._vnode)\n\n    if (vnode == null) {\n      if (container._vnode) {\n        unmount(container._vnode, null, true)\n      }\n    } else {\n      patch(container._vnode || null, vnode, container, null, null)\n    }\n    flushPreFlushCbs()\n    flushPostFlushCbs()\n    container._vnode = vnode\n  }\n\n  return {\n    render,\n    createApp: createAppAPI(render)\n  }\n}\n","import { VNode, createVNode, VNodeArrayChildren, isVNode } from './vnode'\nimport { isObject, isArray } from '../utils'\n\nexport function h(type: any, propsOrChildren?: any, children?: any): VNode {\n  const l = arguments.length\n  if (l === 2) {\n    if (isObject(propsOrChildren) && !isArray(propsOrChildren)) {\n      // single vnode without props\n      if (isVNode(propsOrChildren)) {\n        return createVNode(type, null, [propsOrChildren])\n      }\n      // props without children\n      return createVNode(type, propsOrChildren)\n    } else {\n      // omit props\n      return createVNode(type, null, propsOrChildren)\n    }\n  } else {\n    if (l > 3) {\n      children = Array.prototype.slice.call(arguments, 2)\n    } else if (l === 3 && isVNode(children)) {\n      children = [children]\n    }\n    return createVNode(type, propsOrChildren, children)\n  }\n}\n","import { createRenderer } from './render'\nimport { createElement } from './element'\nimport { createContext } from './context'\n\nexport function createDoCanvas(options) {\n  let doCanvas = {\n    context: createContext(),\n    renderer: createRenderer(options),\n    createElement: createElement\n  }\n\n  doCanvas.renderer.render()\n\n  return doCanvas\n}\n","import { createElement } from './element'\n\nexport function createContext() {\n  let context = {\n    stackingContext: null,\n    body: createElement('body'),\n    getBody() {\n      return context.body\n    }\n  }\n\n  console.log(context.body)\n\n  return context\n}\n"],"names":["__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","this","EMPTY_OBJ","freeze","EMPTY_ARR","onRE","isOn","key","test","isArray","Array","isFunction","val","isString","isObject","normalizeStyle","value","res","item","normalized","parseStringStyle","Boolean","wx","getSystemInfoSync","err","listDelimiterRE","propertyDelimiterRE","styleCommentRE","cssText","ret","replace","split","forEach","tmp","trim","normalizeClass","name_1","_a","Fragment","Symbol","for","Comment","isVNode","__v_isVNode","createVNode","type","props","children","patchFlag","cloned","cloneVNode","vnode","createTextVNode","normalizeChildren","klass","class","style","__v_skip","component","el","staticCount","appContext","ctx","createBaseVNode","extraProps","mergeRef","mergedProps","args","_i","toMerge","existing","incoming","includes","concat","mergeProps","map","deepCloneVNode","text","flag","normalizeVNode","child","slice","cloneIfMounted","String","uid","createAppAPI","render","rootComponent","rootProps","app","_uid","_component","_props","_container","_instance","mount","rootContainer","queue","pendingPostFlushCbs","activePostFlushCbs","postFlushIndex","RECURSION_LIMIT","flushPostFlushCbs","seen","deduped","to","from","pack","ar","l","Set","push","Map","sort","a","b","getId","checkRecursiveUpdates","job","id","Infinity","fn","has","count","get","set","createRenderer","options","canvas","dpr","isTreeNode","__v_isTreeNode","toViewElement","element","paint","renderer","getRenderer","getCtx","getCanvas","_drawBackground","_drawBox","toTextElement","debugColor","compose","funcs","reverse","len","index","f1","result","createBaseElement","__v_isCanvasElement","styles","node","appendChild","treeNode","getContainer","parent","context","isVisible","_children","root","prev","next","hasChildren","Error","_setSibling","_setParent","prependChild","removeChild","append","prepend","remove","createTreeNode","width","height","createElement","XCanvas","createNodeOps","insert","anchor","tag","createText","createComment","setText","setElementText","parentNode","nextSibling","hostInsert","hostRemove","hostPatchProp","patchProp","hostCreateElement","hostCreateText","hostSetText","hostSetElementText","hostNextSibling","patch","n1","n2","container","parentComponent","isSameVNodeType","getNextHostNode","unmount","processText","processElement","mountElement","patchElement","mountChildren","start","oldProps","newProps","patchChildren","patchProps","c1","c2","patchUnkeyedChildren","oldLength","newLength","commonLength","Math","min","nextChild","unmountChildren","doRemove","optimized","_vnode","cb","pre","splice","flushPreFlushCbs","createApp","h","propsOrChildren","createDoCanvas","doCanvas","stackingContext","body","getBody","console","log"],"mappings":"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","x_google_ignoreList":[0]}